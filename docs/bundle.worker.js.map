{"version":3,"file":"bundle.worker.js","mappings":"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","sources":["webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/base.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/getEBMLCuePoint.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/toFlatArray.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/generateEBML.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/makeSimpleBlock.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/toWebM.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/checkFrames.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/getEBMLShell.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/parseWebP.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/parseRIFF2.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/adaptor.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/utils/imageSrcToWebpDataUrl.ts","webpack://webcam-pwa/./node_modules/ts-whammy/src/libs/index.ts","webpack://webcam-pwa/./src/tsWhammyPatch.tsx","webpack://webcam-pwa/./src/Utils/whammy.worker.ts"],"sourcesContent":["export function numToBuffer(num: number): Uint8Array {\n  const parts = []\n  while (num > 0) {\n    parts.push(num & 0xff)\n    num = num >> 8\n  }\n  return new Uint8Array(parts.reverse())\n}\n\nexport function numToFixedBuffer(num: number, size: number): Uint8Array {\n  const parts = new Uint8Array(size)\n  for (let i = size - 1; i >= 0; i--) {\n    parts[i] = num & 0xff\n    num = num >> 8\n  }\n  return parts\n}\n\nexport function strToBuffer(str: string): Uint8Array {\n  const arr = new Uint8Array(str.length)\n  for (let i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i)\n  }\n  return arr\n}\n\nexport function bitsToBuffer(bits: string): Uint8Array {\n  const data = []\n  const pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : ''\n  const curBits = pad + bits\n  for (let i = 0; i < curBits.length; i += 8) {\n    data.push(parseInt(curBits.substr(i, 8), 2))\n  }\n  return new Uint8Array(data)\n}\n\nexport function toBinStr_old(bits: string): string {\n  let data = ''\n  const pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : ''\n  const curBits = pad + bits\n  for (let i = 0; i < curBits.length; i += 8) {\n    data += String.fromCharCode(parseInt(curBits.substr(i, 8), 2))\n  }\n  return data\n}\n\nexport function doubleToString(num: number): string {\n  return [].slice.call(\n      new Uint8Array(new Float64Array([num]).buffer), 0,\n    )\n    .map(e => String.fromCharCode(e))\n    .reverse()\n    .join('')\n}\n","import { IEBMLItem } from '../interfaces'\n\nexport default function(clusterTimecode: number): IEBMLItem {\n  const cuePoint: IEBMLItem = {\n    id: 0xbb, // CuePoint\n    data: [{\n        data: Math.round(clusterTimecode),\n        id: 0xb3, // CueTime\n      },\n      {\n        id: 0xb7, // CueTrackPositions\n        data: [{\n            data: 1,\n            id: 0xf7, // CueTrack\n          },\n          {\n            data: 0, // to be filled in when we know it\n            size: 8,\n            id: 0xf1, // CueClusterPosition\n          },\n        ],\n      },\n    ],\n  }\n  return cuePoint\n}\n","export default function toFlatArray(arr: any[], outBuffer?: any[]): any[] {\n  if (!outBuffer) {\n    outBuffer = []\n  }\n  for (const item of arr) {\n    if (typeof item === 'object' && item[Symbol.iterator]) {\n      toFlatArray(item, outBuffer)\n    } else {\n      outBuffer.push(item)\n    }\n  }\n  return outBuffer\n}\n","import {\n  numToFixedBuffer,\n  strToBuffer,\n  bitsToBuffer,\n  numToBuffer,\n} from './base'\nimport toFlatArray from './toFlatArray'\nimport { IEBML } from '../interfaces'\n\nexport default function generateEBML(json: IEBML, outputAsArray?: boolean): Blob | Uint8Array {\n  const ebml = []\n\n  for (const item of json) {\n    if (!('id' in item)) {\n      // already encoded blob or byteArray\n      ebml.push(item)\n      continue\n    }\n\n    let data = item.data\n    if (typeof data === 'object') {\n      data = generateEBML(data, outputAsArray)\n    }\n    if (typeof data === 'number') {\n      data = ('size' in item) ? numToFixedBuffer(data, item.size || 0) : bitsToBuffer(data.toString(2))\n    }\n    if (typeof data === 'string') {\n      data = strToBuffer(data)\n    }\n\n    // if (data.length) {\n    //   const z = z\n    // }\n\n    const len = data.size || data.byteLength || data.length\n    const zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8)\n    const sizeStr = len.toString(2)\n    const padded = (new Array((zeroes * 7 + 7 + 1) - sizeStr.length)).join('0') + sizeStr\n    const size = (new Array(zeroes)).join('0') + '1' + padded\n\n    // i actually dont quite understand what went on up there, so I'm not really\n    // going to fix this, i'm probably just going to write some hacky thing which\n    // converts that string into a buffer-esque thing\n\n    ebml.push(numToBuffer(item.id))\n    ebml.push(bitsToBuffer(size))\n    ebml.push(data)\n  }\n\n  // output as blob or byteArray\n  if (outputAsArray) {\n    // convert ebml to an array\n    const buffer = toFlatArray(ebml)\n    return new Uint8Array(buffer)\n  } else {\n    return new Blob(ebml, {\n      type: 'video/webm',\n    })\n  }\n}\n","import { ISimpleBlockData } from '../interfaces'\n\nexport default function makeSimpleBlock(data: ISimpleBlockData): string {\n  let flags = 0\n  if (data.keyframe) { flags |= 128 }\n  if (data.invisible) { flags |= 8 }\n  if (data.lacing) { flags |= (data.lacing << 1) }\n  if (data.discardable) { flags |= 1 }\n  if (data.trackNum > 127) {\n    throw new Error('TrackNumber > 127 not supported')\n  }\n  const out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags]\n    .map(e => {\n      return String.fromCharCode(e)\n    }).join('') + data.frame\n\n  return out\n}\n","import getEBMLShell from './getEBMLShell'\nimport getEBMLCuePoint from './getEBMLCuePoint'\nimport generateEBML from './generateEBML'\nimport checkFrames from './checkFrames'\nimport makeSimpleBlock from './makeSimpleBlock'\nimport { IWebPFrame } from '../interfaces'\n\nexport default function toWebM(frames: IWebPFrame[], outputAsArray?: boolean): Blob | Uint8Array {\n  const info = checkFrames(frames)\n\n  // max duration by cluster in milliseconds\n  const CLUSTER_MAX_DURATION = 30000\n  const EBML = getEBMLShell(info)\n  const segment = EBML[1]\n  const cues = segment.data[2]\n\n  // Generate clusters (max duration)\n  let frameNumber = 0\n  let clusterTimecode = 0\n\n  while (frameNumber < frames.length) {\n    const cuePoint = getEBMLCuePoint(clusterTimecode)\n    cues.data.push(cuePoint)\n    const clusterFrames = []\n    let clusterDuration = 0\n\n    do {\n      clusterFrames.push(frames[frameNumber])\n      clusterDuration += frames[frameNumber].duration\n      frameNumber++\n    } while (frameNumber < frames.length && clusterDuration < CLUSTER_MAX_DURATION)\n\n    let clusterCounter = 0\n\n    const clusterDataList = clusterFrames.map(webp => {\n      const block = makeSimpleBlock({\n        discardable: 0,\n        frame: webp.data.slice(4),\n        invisible: 0,\n        keyframe: 1,\n        lacing: 0,\n        trackNum: 1,\n        timecode: Math.round(clusterCounter),\n      })\n      clusterCounter += webp.duration\n      return {\n        data: block,\n        id: 0xa3,\n      }\n    })\n\n    const cluster = {\n      id: 0x1f43b675, // Cluster\n      data: [{\n        data: Math.round(clusterTimecode),\n        id: 0xe7, // Timecode\n      }, ...clusterDataList],\n    }\n\n    // Add cluster to segment\n    segment.data.push(cluster)\n    clusterTimecode += clusterDuration\n  }\n\n  // First pass to compute cluster positions\n  let position = 0\n\n  for (let i = 0; i < segment.data.length; i++) {\n    if (i >= 3) {\n      cues.data[i - 3].data[1].data[1].data = position\n    }\n    const data = generateEBML([segment.data[i]], outputAsArray)\n    if (typeof Blob !== 'undefined' && data instanceof Blob) {\n      position += data.size\n    }\n    if (data instanceof Uint8Array) {\n      position += data.byteLength\n    }\n    if (i !== 2) { // not cues\n      // Save results to avoid having to encode everything twice\n      segment.data[i] = data\n    }\n  }\n\n  return generateEBML(EBML, outputAsArray)\n}\n","import { IWebPFrame,  IFramesInfo } from '../interfaces'\n\nexport default function checkFrames(frames: IWebPFrame[]): IFramesInfo {\n  const width = frames[0].width\n  const height = frames[0].height\n  let duration = frames[0].duration\n\n  for (let i = 1; i < frames.length; i++) {\n    if (frames[i].width !== width) {\n      throw new Error('Frame ' + (i + 1) + ' has a different width')\n    }\n    if (frames[i].height !== height) {\n      throw new Error('Frame ' + (i + 1) + ' has a different height')\n    }\n    if (frames[i].duration < 0 || frames[i].duration > 0x7fff) {\n      throw new Error('Frame ' + (i + 1) + ' has a weird duration (must be between 0 and 32767)')\n    }\n    duration += frames[i].duration\n  }\n\n  return {\n    duration,\n    width,\n    height,\n  }\n}\n","import { doubleToString } from './base'\nimport { IFramesInfo, IEBML } from '../interfaces'\n\nexport default function getEBMLShell(info: IFramesInfo): IEBML {\n  const EBML: IEBML = [{\n      id: 0x1a45dfa3, // EBML\n      data: [{\n          data: 1,\n          id: 0x4286, // EBMLVersion\n        },\n        {\n          data: 1,\n          id: 0x42f7, // EBMLReadVersion\n        },\n        {\n          data: 4,\n          id: 0x42f2, // EBMLMaxIDLength\n        },\n        {\n          data: 8,\n          id: 0x42f3, // EBMLMaxSizeLength\n        },\n        {\n          data: 'webm',\n          id: 0x4282, // DocType\n        },\n        {\n          data: 2,\n          id: 0x4287, // DocTypeVersion\n        },\n        {\n          data: 2,\n          id: 0x4285, // DocTypeReadVersion\n        },\n      ],\n    },\n    {\n      id: 0x18538067, // Segment\n      data: [{\n          id: 0x1549a966, // Info\n          data: [{\n              data: 1e6, // do things in millisecs (num of nanosecs for duration scale)\n              id: 0x2ad7b1, // TimecodeScale\n            },\n            {\n              data: 'whammy',\n              id: 0x4d80, // MuxingApp\n            },\n            {\n              data: 'whammy',\n              id: 0x5741, // WritingApp\n            },\n            {\n              data: doubleToString(info.duration),\n              id: 0x4489, // Duration\n            },\n          ],\n        },\n        {\n          id: 0x1654ae6b, // Tracks\n          data: [{\n            id: 0xae, // TrackEntry\n            data: [{\n                data: 1,\n                id: 0xd7, // TrackNumber\n              },\n              {\n                data: 1,\n                id: 0x73c5, // TrackUID\n              },\n              {\n                data: 0,\n                id: 0x9c, // FlagLacing\n              },\n              {\n                data: 'und',\n                id: 0x22b59c, // Language\n              },\n              {\n                data: 'V_VP8',\n                id: 0x86, // CodecID\n              },\n              {\n                data: 'VP8',\n                id: 0x258688, // CodecName\n              },\n              {\n                data: 1,\n                id: 0x83, // TrackType\n              },\n              {\n                id: 0xe0, // Video\n                data: [{\n                    data: info.width,\n                    id: 0xb0, // PixelWidth\n                  },\n                  {\n                    data: info.height,\n                    id: 0xba, // PixelHeight\n                  },\n                ],\n              },\n            ],\n          }],\n        },\n        {\n          id: 0x1c53bb6b, // Cues\n          data: [\n            // cue insertion point\n          ],\n        },\n\n        // cluster insertion point\n      ],\n    },\n  ]\n  return EBML\n}\n","import { IRiff, IWebP } from '../interfaces'\n\nexport default function parseWebP(riff: IRiff): IWebP {\n  const VP8 = riff.RIFF[0].WEBP[0]\n\n  // A VP8 keyframe starts with the 0x9d012a header\n  const frameStart = VP8.indexOf('\\x9d\\x01\\x2a')\n  const c: number[] = []\n\n  for (let i = 0; i < 4; i++) {\n    c[i] = VP8.charCodeAt(frameStart + 3 + i)\n  }\n\n  // the code below is literally copied verbatim from the bit stream spec\n  let tmp = (c[1] << 8) | c[0]\n  const width = tmp & 0x3FFF\n  // const horizontal_scale = tmp >> 14;\n  tmp = (c[3] << 8) | c[2]\n  const height = tmp & 0x3FFF\n  // const vertical_scale = tmp >> 14;\n\n  return {\n    width,\n    height,\n    data: VP8,\n    riff,\n  }\n}\n","// https://github.com/antimatter15/whammy/issues/70\n// https://github.com/Akimyou/ts-whammy/issues/29\n\nimport { IRiff } from '../interfaces'\n\ntype ChunkSizeAndBinaryData = string\n\nfunction readUint32LittleEndian(buffer: string, offset: number): number {\n  const val = parseInt(\n    buffer\n      .substr(offset, 4)\n      .split('')\n      .map(i => {\n        const unpadded = i.charCodeAt(0).toString(2)\n        return new Array(8 - unpadded.length + 1).join('0') + unpadded\n      })\n      .reverse()\n      .join(''),\n    2,\n  )\n  return val\n}\n\n/**\n * 对于 VP8X，需要提取出其中的 VP8 或 VP8L bit stream chunk。\n * 关于 VP8X 格式，参见 Extended file format: https://developers.google.com/speed/webp/docs/riff_container#extended_file_format\n * @param buffer VP8X Chunk数据，不含 'VP8X' tag\n */\nfunction extractBitStreamFromVp8x(buffer: string): ChunkSizeAndBinaryData {\n  /*\n   32bit VP8X Chunk size\n   8bit Flags: Rsv I L E X A R\n   24bit Reserved\n   24bit Canvas Width Minus One\n   24bit Canvas Height Minus One\n  */\n  let offset = 4 + 1 + 3 + 3 + 3\n  while (offset < buffer.length) {\n    const chunkTag = buffer.substr(offset, 4)\n    offset += 4\n    const chunkSize = readUint32LittleEndian(buffer, offset)\n    offset += 4\n    switch (chunkTag) {\n      case 'VP8 ':\n      case 'VP8L':\n        // eslint-disable-next-line no-case-declarations\n        const size = buffer.substr(offset - 4, 4)\n        // eslint-disable-next-line no-case-declarations\n        const body = buffer.substr(offset, chunkSize)\n        return size + body\n      default:\n        offset += chunkSize\n        break\n    }\n  }\n  throw new Error('VP8X format error: missing VP8/VP8L chunk.')\n}\n\nexport default function parseRIFF(str: string): IRiff {\n  let offset = 0\n  const chunks: {\n    [index: string]: any,\n  } = {}\n\n  while (offset < str.length) {\n    const id = str.substr(offset, 4)\n    chunks[id] = chunks[id] || []\n    if (id === 'RIFF' || id === 'LIST') {\n      const len = readUint32LittleEndian(str, offset + 4)\n      const data = str.substr(offset + 4 + 4, len)\n      offset += 4 + 4 + len\n      chunks[id].push(parseRIFF(data))\n    } else if (id === 'WEBP') {\n      const vpVersion = str.substr(offset + 4, 4)\n      switch (vpVersion) {\n        case 'VP8X':\n          chunks[id].push(extractBitStreamFromVp8x(str.substr(offset + 8)))\n          break\n        case 'VP8 ':\n        case 'VP8L':\n          // Use (offset + 8) to skip past 'VP8 ' / 'VP8L' field after 'WEBP'\n          chunks[id].push(str.substr(offset + 8))\n          break\n        default:\n          // eslint-disable-next-line no-console\n          console.error(`not supported webp version: '${vpVersion}'`)\n          break\n      }\n      offset = str.length\n    } else {\n      // Unknown chunk type push entire payload\n      chunks[id].push(str.substr(offset + 4))\n      offset = str.length\n    }\n  }\n  return (chunks as any) as IRiff\n}\n","export function autoAtob(str: string) {\n  if (typeof atob !== 'undefined') {\n    return atob(str)\n  }\n  return Buffer.from(str, 'base64').toString('binary')\n}\n","export interface ImageSrcToWebpDataUrlOptions {\n  width?: number;\n  height?: number;\n  backgroundColor?: string;\n}\n\nexport const imageSrcToWebpDataUrl = (\n  src: string,\n  options?: ImageSrcToWebpDataUrlOptions\n) => {\n  return new Promise<string>((resolve, reject) => {\n    const img = new Image();\n    img.src = src;\n    img.onload = () => {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\")!;\n      canvas.width = options?.width || img.width;\n      canvas.height = options?.height || img.height;\n      ctx.fillStyle = options?.backgroundColor || '#000';\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\n      ctx?.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);\n      const webp = canvas.toDataURL(\"image/webp\");\n      resolve(webp);\n    };\n    img.onerror = (error) => {\n      reject(error);\n    };\n  });\n};","import toWebM from './utils/toWebM'\nimport parseWebP from './utils/parseWebP'\nimport parseRIFF from './utils/parseRIFF2'\nimport { autoAtob } from './utils/adaptor'\nimport { IWebP, IWebPFrame } from './interfaces'\nimport { ImageSrcToWebpDataUrlOptions, imageSrcToWebpDataUrl } from './utils/imageSrcToWebpDataUrl'\n\ninterface IFromImageArrayOptions {\n  fps?: number\n  duration?: number\n  outputAsArray?: boolean\n}\n\nconst defaultFps = 1\n\nexport default {\n  fromImageArray(images: string[], fps: number, outputAsArray?: boolean): Blob | Uint8Array {\n    const curOutputAsArray = typeof Blob !== 'undefined' ? outputAsArray : true\n    const curFps = fps || defaultFps\n    return toWebM(images.map((image, index) => {\n      try {\n        const webp: IWebP = parseWebP(parseRIFF(autoAtob(image.slice(23))))\n        const webpFrame: IWebPFrame = {\n          ...webp,\n          duration: 1000 / curFps,\n        }\n        return webpFrame \n      } catch (error) {\n        console.error(`Before toWebM Error, Image Index ${index}`)\n        throw error;\n      }\n    }), curOutputAsArray)\n  },\n  fromImageArrayWithOptions(images: string[], options: IFromImageArrayOptions = {}):  Blob | Uint8Array {\n    const { fps, duration, outputAsArray } = options\n    let curFps = fps || defaultFps\n    if (duration) {\n      curFps = 1000 / ((duration * 1000) / images.length)\n    }\n    return this.fromImageArray(images, curFps, outputAsArray)\n  },\n  async fixImageDataList(images: string[], options?: ImageSrcToWebpDataUrlOptions): Promise<string[]> {\n    const result: string[] = []\n    for (const item of images) {\n      const temp = await imageSrcToWebpDataUrl(item, options);\n      result.push(temp)\n    }\n    return result\n  }\n}\n","import tsWhammy from \"ts-whammy/src/libs\";\r\nimport { IWebP, IWebPFrame } from \"ts-whammy/src/libs/interfaces\";\r\nimport { autoAtob } from \"ts-whammy/src/libs/utils/adaptor\";\r\nimport parseRIFF from \"ts-whammy/src/libs/utils/parseRIFF2\";\r\nimport parseWebP from \"ts-whammy/src/libs/utils/parseWebP\";\r\nimport toWebM from \"ts-whammy/src/libs/utils/toWebM\";\r\n\r\nconsole.warn(\"Applying whammy patch\");\r\n\r\n// We need the index of the error message here\r\n//@ts-ignore\r\ntsWhammy.modifiedFromImageArray = function (\r\n  images: string[],\r\n  fps: number,\r\n  updateProgress: (index: any) => void\r\n): Blob | Uint8Array {\r\n  const curOutputAsArray = typeof Blob !== \"undefined\" ? false : true;\r\n  const curFps = fps || 1;\r\n  return toWebM(\r\n    images.map((image, index) => {\r\n      updateProgress(index);\r\n      try {\r\n        const webp: IWebP = parseWebP(parseRIFF(autoAtob(image.slice(23))));\r\n        const webpFrame: IWebPFrame = {\r\n          ...webp,\r\n          duration: 1000 / curFps,\r\n        };\r\n        return webpFrame;\r\n      } catch (error) {\r\n        console.error(error);\r\n        throw new Error(`Before toWebM Error, Image Index ${index}`);\r\n      }\r\n    }),\r\n    curOutputAsArray\r\n  );\r\n};\r\n\r\nexport const getPatchedWhammy = () => {\r\n  return tsWhammy;\r\n};\r\n","import { getPatchedWhammy } from \"../tsWhammyPatch\";\r\n\r\nconsole.warn(\"Loading whammy worker\");\r\n\r\nonmessage = async (event) => {\r\n  const { images, fps, updateProgress } = event.data;\r\n  console.warn(\r\n    \"Whammy worker running!\",\r\n    images,\r\n    fps,\r\n    getPatchedWhammy().fromImageArray\r\n  );\r\n\r\n  const callback = (index) => {\r\n    postMessage({ type: \"Progress\", value: index });\r\n  };\r\n\r\n  const videoBlob = getPatchedWhammy().modifiedFromImageArray(\r\n    images,\r\n    fps,\r\n    callback\r\n  );\r\n  postMessage({ type: \"Result\", value: videoBlob });\r\n};\r\n\r\nexport default {}; // Add a default export to satisfy the linter\r\n"],"names":["numToBuffer","num","parts","push","Uint8Array","reverse","numToFixedBuffer","size","i","strToBuffer","str","arr","length","charCodeAt","bitsToBuffer","bits","data","curBits","Array","join","parseInt","substr","clusterTimecode","id","Math","round","toFlatArray","outBuffer","item","Symbol","iterator","generateEBML","json","outputAsArray","ebml","toString","len","byteLength","zeroes","ceil","log","sizeStr","padded","buffer","Blob","type","makeSimpleBlock","flags","keyframe","invisible","lacing","discardable","trackNum","Error","timecode","map","e","String","fromCharCode","frame","toWebM","frames","info","width","height","duration","checkFrames","EBML","slice","call","Float64Array","getEBMLShell","segment","cues","frameNumber","cuePoint","getEBMLCuePoint","clusterFrames","clusterDuration","clusterCounter","clusterDataList","webp","block","cluster","position","parseWebP","riff","VP8","RIFF","WEBP","frameStart","indexOf","c","tmp","readUint32LittleEndian","offset","split","unpadded","extractBitStreamFromVp8x","chunkTag","chunkSize","parseRIFF","chunks","vpVersion","console","error","autoAtob","atob","Buffer","from","imageSrcToWebpDataUrl","src","options","Promise","resolve","reject","img","Image","onload","canvas","document","createElement","ctx","getContext","fillStyle","backgroundColor","fillRect","drawImage","toDataURL","onerror","fromImageArray","images","fps","curOutputAsArray","curFps","image","index","fromImageArrayWithOptions","this","fixImageDataList","result","temp","warn","tsWhammy","modifiedFromImageArray","updateProgress","_objectSpread","concat","getPatchedWhammy","onmessage","async","event","videoBlob","postMessage","value"],"sourceRoot":""}